// Package slidingwindow демонстрирует паттерн "Скользящее окно"
package slidingwindow

// MaxSumSubarray находит максимальную сумму подмассива размера k
// Временная сложность: O(n)
// Пространственная сложность: O(1)
//
// Пример:
//
//	arr := []int{2, 1, 5, 1, 3, 2}
//	k := 3
//	result := MaxSumSubarray(arr, k) // Вернёт 9 (подмассив [5, 1, 3])
func MaxSumSubarray(arr []int, k int) int {
	// Проверка граничных условий
	if len(arr) < k || k <= 0 {
		return 0
	}

	// Вычисляем сумму первого окна
	windowSum := 0
	for i := 0; i < k; i++ {
		windowSum += arr[i]
	}

	maxSum := windowSum

	// Скользим окном по массиву
	// На каждом шаге: добавляем новый элемент справа, убираем элемент слева
	for i := k; i < len(arr); i++ {
		windowSum += arr[i] - arr[i-k] // Добавляем новый, убираем старый
		if windowSum > maxSum {
			maxSum = windowSum
		}
	}

	return maxSum
}

// MinSubarrayLen находит минимальную длину подмассива с суммой >= target
// Использует динамическое скользящее окно
// Временная сложность: O(n) - каждый элемент обрабатывается максимум дважды
// Пространственная сложность: O(1) - используем только несколько переменных
//
// Алгоритм:
// 1. Расширяем окно справа, добавляя элементы
// 2. Когда сумма >= target, пытаемся сжать окно слева
// 3. Обновляем минимальную длину при каждом сжатии
// 4. Повторяем до конца массива
//
// Пример:
//
//	arr := []int{2, 1, 5, 2, 3, 2}
//	target := 7
//	result := MinSubarrayLen(arr, target) // Вернёт 2 (подмассив [5, 2])
//
//	Пошагово:
//	[2] → сумма=2 < 7, расширяем
//	[2,1] → сумма=3 < 7, расширяем
//	[2,1,5] → сумма=8 >= 7! Длина=3, minLength=3, сжимаем
//	[1,5] → сумма=6 < 7, расширяем
//	[1,5,2] → сумма=8 >= 7! Длина=3, сжимаем
//	[5,2] → сумма=7 >= 7! Длина=2, minLength=2 ✓, сжимаем
//	[2] → сумма=2 < 7, расширяем
//	[2,3] → сумма=5 < 7, расширяем
//	[2,3,2] → сумма=7 >= 7! Длина=3, minLength=2, сжимаем
//	[3,2] → сумма=5 < 7, конец
func MinSubarrayLen(arr []int, target int) int {
	// Проверка граничных условий
	if len(arr) == 0 {
		return 0
	}

	// Инициализируем значением больше максимально возможного
	// Это позволяет определить, был ли найден подходящий подмассив
	minLength := len(arr) + 1
	windowSum := 0   // Текущая сумма элементов в окне
	windowStart := 0 // Начало окна (левый указатель)

	// Правый указатель движется по массиву
	for windowEnd := 0; windowEnd < len(arr); windowEnd++ {
		// ШАГ 1: Расширяем окно, добавляя элемент справа
		windowSum += arr[windowEnd]

		// ШАГ 2: Сжимаем окно слева, пока сумма >= target
		// Это жадный подход: как только сумма достаточна,
		// пытаемся уменьшить окно для поиска более короткого подмассива
		for windowSum >= target {
			// Вычисляем текущую длину окна
			currentLength := windowEnd - windowStart + 1

			// Обновляем минимальную длину, если нашли более короткий подмассив
			if currentLength < minLength {
				minLength = currentLength
			}

			// Убираем элемент слева и сдвигаем начало окна
			// Это уменьшает сумму и размер окна
			windowSum -= arr[windowStart]
			windowStart++
		}
		// После выхода из внутреннего цикла:
		// - либо сумма < target (нужно расширять окно)
		// - либо окно стало пустым (windowStart > windowEnd)
	}

	// Если не нашли подходящий подмассив, minLength останется > len(arr)
	if minLength > len(arr) {
		return 0
	}

	return minLength
}

// LongestSubstringKDistinct находит длину самой длинной подстроки с не более чем k различными символами
// Временная сложность: O(n) - каждый символ обрабатывается максимум дважды
// Пространственная сложность: O(k) - храним не более k+1 символов в хеш-таблице
//
// Алгоритм:
// 1. Расширяем окно справа, добавляя символы
// 2. Отслеживаем количество различных символов через хеш-таблицу
// 3. Когда различных символов > k, сжимаем окно слева
// 4. Обновляем максимальную длину после каждого расширения
//
// Пример:
//
//	s := "araaci"
//	k := 2
//	result := LongestSubstringKDistinct(s, k) // Вернёт 4 ("araa")
//
//	Пошагово:
//	[a] → {a:1}, различных=1, длина=1, max=1
//	[ar] → {a:1, r:1}, различных=2, длина=2, max=2
//	[ara] → {a:2, r:1}, различных=2, длина=3, max=3
//	[araa] → {a:3, r:1}, различных=2, длина=4, max=4 ✓
//	[araac] → {a:3, r:1, c:1}, различных=3 > k! Сжимаем:
//	[raac] → {r:1, a:2, c:1}, различных=3 > k! Сжимаем:
//	[aac] → {a:2, c:1}, различных=2, длина=3, max=4
//	[aaci] → {a:2, c:1, i:1}, различных=3 > k! Сжимаем:
//	[aci] → {a:1, c:1, i:1}, различных=3 > k! Сжимаем:
//	[ci] → {c:1, i:1}, различных=2, длина=2, max=4
func LongestSubstringKDistinct(s string, k int) int {
	if len(s) == 0 || k == 0 {
		return 0
	}

	// Хеш-таблица для подсчёта частоты каждого символа в текущем окне
	// Ключ: символ, Значение: количество вхождений
	charCount := make(map[byte]int)
	maxLength := 0   // Максимальная найденная длина подстроки
	windowStart := 0 // Начало окна (левый указатель)

	// Правый указатель движется по строке
	for windowEnd := 0; windowEnd < len(s); windowEnd++ {
		// ШАГ 1: Расширяем окно, добавляя символ справа
		rightChar := s[windowEnd]
		charCount[rightChar]++ // Увеличиваем счётчик символа

		// ШАГ 2: Сжимаем окно, пока различных символов больше k
		// len(charCount) возвращает количество различных символов в окне
		for len(charCount) > k {
			leftChar := s[windowStart]
			charCount[leftChar]-- // Уменьшаем счётчик символа слева

			// Важно: удаляем символ из мапы, если его счётчик стал 0
			// Это необходимо, чтобы len(charCount) корректно отражал
			// количество различных символов в окне
			if charCount[leftChar] == 0 {
				delete(charCount, leftChar)
			}

			windowStart++ // Сдвигаем левый указатель вправо
		}

		// ШАГ 3: Обновляем максимальную длину
		// После сжатия (если было) окно содержит <= k различных символов
		currentLength := windowEnd - windowStart + 1
		if currentLength > maxLength {
			maxLength = currentLength
		}
	}

	return maxLength
}

// FindAverages вычисляет средние значения для всех подмассивов размера k
// Временная сложность: O(n)
// Пространственная сложность: O(n) для результата
//
// Пример:
//
//	arr := []int{1, 3, 2, 6, -1, 4, 1, 8, 2}
//	k := 5
//	result := FindAverages(arr, k) // Вернёт [2.2, 2.8, 2.4, 3.6, 2.8]
func FindAverages(arr []int, k int) []float64 {
	if len(arr) < k || k <= 0 {
		return []float64{}
	}

	result := make([]float64, len(arr)-k+1)
	windowSum := 0

	// Считаем сумму первого окна
	for i := 0; i < k; i++ {
		windowSum += arr[i]
	}
	result[0] = float64(windowSum) / float64(k)

	// Скользим по массиву
	for i := k; i < len(arr); i++ {
		windowSum += arr[i] - arr[i-k]
		result[i-k+1] = float64(windowSum) / float64(k)
	}

	return result
}
